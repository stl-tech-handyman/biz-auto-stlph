<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quote Engine Test Dashboard</title>
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="/static/css/bootstrap-icons.css" rel="stylesheet">
    <link href="/static/css/admin-shared.css" rel="stylesheet">
    <link href="/static/css/server-timer.css" rel="stylesheet">
    <!-- DataTables CSS -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.7/css/dataTables.bootstrap5.min.css">
    <link rel="stylesheet" href="https://cdn.datatables.net/buttons/2.4.2/css/buttons.bootstrap5.min.css">
    <style>
        /* Test status indicator square */
        .test-status-indicator {
            width: 100%;
            height: 8px;
            border-radius: 0 0 12px 12px;
            background-color: transparent;
            transition: background-color 0.3s ease;
            position: relative;
            z-index: 1;
        }
        
        .test-status-indicator.status-pass {
            background-color: rgba(76, 175, 80, 0.2); /* 20% opacity of #4caf50 (green) */
            box-shadow: none;
        }
        
        .test-status-indicator.status-fail {
            background-color: rgba(244, 67, 54, 0.2); /* 20% opacity of #f44336 (red) */
            box-shadow: none;
        }
        
        .test-status-indicator.status-warning {
            background-color: rgba(255, 152, 0, 0.2); /* 20% opacity of #ff9800 (orange) */
            box-shadow: none;
        }
        
        /* Fix dark shadow on green badges */
        .badge.bg-success {
            box-shadow: none !important;
            text-shadow: none;
        }
        
        /* Ensure test cards don't have dark shadows on corners */
        .test-card {
            box-shadow: 0 2px 4px rgba(0,0,0,0.08) !important;
        }
        
        .test-card:hover {
            box-shadow: 0 6px 12px rgba(0,0,0,0.12) !important;
        }
        
        .test-card .card-body {
            position: relative;
            z-index: 2;
        }
        
        /* Filter/Group controls */
        .filter-controls {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        /* Reduce overall page padding */
        .container {
            padding-top: 1rem;
        }
        
        /* Reduce card padding */
        .card-body {
            padding: 1rem !important;
        }
        
        .card-header {
            padding: 0.75rem 1rem !important;
        }
        
        /* Reduce section margins */
        .row {
            margin-bottom: 1rem !important;
        }
        
        .mb-4 {
            margin-bottom: 1rem !important;
        }
        
        .mb-5 {
            margin-bottom: 1.5rem !important;
        }
        
        .mb-3 {
            margin-bottom: 0.75rem !important;
        }
        
        /* Reduce header section padding */
        .header-section {
            padding: 1.5rem 0 !important;
        }
        
        .header-section h1 {
            margin-bottom: 0.5rem !important;
        }
        
        /* Reduce test card wrapper spacing */
        .test-card-wrapper {
            margin-bottom: 1rem !important;
        }
        
        /* Reduce list item spacing */
        .list-unstyled li {
            margin-bottom: 0.5rem !important;
        }
        
        /* Reduce text paragraph margins */
        p {
            margin-bottom: 0.75rem !important;
        }
        
        .filter-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        
        .filter-group:last-child {
            margin-bottom: 0;
        }
        
        .filter-label {
            font-weight: 600;
            color: #495057;
            margin-right: 0.5rem;
            white-space: nowrap;
        }
        
        .filter-btn {
            border: 2px solid #dee2e6;
            background: white;
            color: #495057;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            white-space: nowrap;
        }
        
        .filter-btn:hover {
            border-color: #0d6efd;
            color: #0d6efd;
            background: #f0f7ff;
        }
        
        .filter-btn.active {
            background: #0d6efd;
            border-color: #0d6efd;
            color: white;
        }
        
        /* Status filter buttons with background colors */
        .status-filter[data-status-filter="pass"]:not(.active) {
            background: rgba(76, 175, 80, 0.3); /* 30% opacity green */
        }
        
        .status-filter[data-status-filter="warning"]:not(.active) {
            background: rgba(255, 152, 0, 0.3); /* 30% opacity orange */
        }
        
        .status-filter[data-status-filter="fail"]:not(.active) {
            background: rgba(244, 67, 54, 0.3); /* 30% opacity red */
        }
        
        .status-filter[data-status-filter="none"]:not(.active) {
            background: rgba(158, 158, 158, 0.3); /* 30% opacity gray for "Not Run" */
        }
        
        .test-card.hidden {
            display: none;
        }
        
        .test-card-group {
            margin-bottom: 1rem;
        }
        
        .group-header {
            font-size: 1.1rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #dee2e6;
        }
        
        /* Inline test results container */
        .test-results-container {
            margin-top: 1rem;
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .test-results-container .card {
            border: 1px solid #dee2e6;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .test-results-container .card-header {
            background-color: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }
        
        .test-card-wrapper {
            margin-bottom: 1.5rem;
        }
        
        /* Year/Month selector for pricing rates */
        .year-selector-group {
            display: flex;
            flex-direction: column;
            margin-right: 1rem;
            margin-bottom: 1rem;
        }
        
        .year-btn {
            min-width: 100px;
            font-weight: 600;
        }
        
        .month-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 0.5rem;
        }
        
        .month-btn {
            min-width: 60px;
            font-size: 0.85rem;
        }

    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark">
        <div class="container">
            <a class="navbar-brand" href="/">
                <i class="bi bi-star-fill me-2"></i>STL Party Helpers
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="/test-dashboard.html">Tests</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/quote-preview.html">Quote Preview</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/quote-test-all.html">Quote Test All</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/pdf-feature-docs.html">PDF Feature Docs</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/docs/internal/">Documentation</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    
    <!-- Header -->
    <div class="header-section">
        <div class="container">
            <h1 class="display-5 fw-bold mb-3">
                <i class="bi bi-clipboard-check me-2"></i>Quote Engine Test Dashboard
            </h1>
            <p class="lead mb-0">Comprehensive testing suite for all quote engine features</p>
        </div>
    </div>
    
    <div class="container">
        <!-- Configuration Info Section -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="card border-info">
                    <div class="card-header" style="background-color: #4a148c; color: white;">
                        <h5 class="mb-0">
                            <i class="bi bi-gear-fill me-2"></i>Configuration Variables
                        </h5>
                    </div>
                    <div class="card-body">
                        <p class="text-muted mb-3" style="font-size: 0.9rem;">
                            Location settings (office coordinates, service radius) are stored in business configuration files. 
                            These settings control travel fee calculations and service area boundaries.
                        </p>
                        <div class="row">
                            <div class="col-md-6">
                                <h6 class="fw-bold mb-2">Business Configuration</h6>
                                <ul class="list-unstyled mb-0">
                                    <li class="mb-2">
                                        <i class="bi bi-file-earmark-code text-primary me-2"></i>
                                        <strong>File:</strong> 
                                        <code class="ms-1">config/businesses/stlpartyhelpers.yaml</code>
                                    </li>
                                    <li class="mb-2">
                                        <i class="bi bi-geo-alt text-primary me-2"></i>
                                        <strong>Location Section:</strong> <code>location</code>
                                    </li>
                                    <li class="mb-2">
                                        <i class="bi bi-pin-map text-primary me-2"></i>
                                        <strong>Fields:</strong> <code>lat</code>, <code>lng</code>, <code>serviceRadiusMiles</code>
                                    </li>
                                </ul>
                            </div>
                            <div class="col-md-6">
                                <h6 class="fw-bold mb-2">Code Implementation</h6>
                                <ul class="list-unstyled mb-0">
                                    <li class="mb-2">
                                        <i class="bi bi-code-square text-primary me-2"></i>
                                        <strong>Domain Model:</strong> 
                                        <code class="ms-1">go/internal/domain/business.go</code>
                                    </li>
                                    <li class="mb-2">
                                        <i class="bi bi-gear text-primary me-2"></i>
                                        <strong>Helper Functions:</strong> 
                                        <code class="ms-1">go/internal/infra/geo/geocoding.go</code>
                                    </li>
                                    <li class="mb-2">
                                        <i class="bi bi-envelope text-primary me-2"></i>
                                        <strong>Usage:</strong> 
                                        <code class="ms-1">go/internal/http/handlers/email_handler.go</code>
                                    </li>
                                </ul>
                            </div>
                        </div>
                        <div class="mt-3 pt-3 border-top">
                            <small class="text-muted">
                                <i class="bi bi-info-circle me-1"></i>
                                <strong>Note:</strong> Changes to configuration require server restart. 
                                The system uses explicit <code>lat</code>/<code>lng</code> coordinates when provided (recommended for accuracy), 
                                otherwise falls back to geocoding the <code>distanceOrigin</code> address.
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Filter/Group Controls -->
        <div class="filter-controls">
            <div class="filter-group">
                <span class="filter-label">
                    <i class="bi bi-funnel me-1"></i>Group by:
                </span>
                <button class="filter-btn active" data-group-mode="category" onclick="setGroupMode('category')">
                    <i class="bi bi-tags me-1"></i>Category
                </button>
                <button class="filter-btn" data-group-mode="type" onclick="setGroupMode('type')">
                    <i class="bi bi-diagram-3 me-1"></i>Test Type
                </button>
                <button class="filter-btn" data-group-mode="component" onclick="setGroupMode('component')">
                    <i class="bi bi-layers me-1"></i>Component
                </button>
            </div>
            <div class="filter-group">
                <span class="filter-label">
                    <i class="bi bi-funnel-fill me-1"></i>Status:
                </span>
                <button class="filter-btn status-filter active" data-status-filter="all" onclick="setStatusFilter('all')">
                    <i class="bi bi-list-ul me-1"></i>All
                </button>
                <button class="filter-btn status-filter" data-status-filter="pass" onclick="setStatusFilter('pass')">
                    <i class="bi bi-check-circle me-1"></i>Passed
                </button>
                <button class="filter-btn status-filter" data-status-filter="warning" onclick="setStatusFilter('warning')">
                    <i class="bi bi-exclamation-triangle me-1"></i>Warning
                </button>
                <button class="filter-btn status-filter" data-status-filter="fail" onclick="setStatusFilter('fail')">
                    <i class="bi bi-x-circle me-1"></i>Failed
                </button>
                <button class="filter-btn status-filter" data-status-filter="none" onclick="setStatusFilter('none')">
                    <i class="bi bi-dash-circle me-1"></i>Not Run
                </button>
            </div>
            <div class="filter-group" id="filter-tags-container">
                <!-- Filter tags will be dynamically generated here -->
            </div>
        </div>
        
        <!-- Run All Tests Button -->
        <div class="text-center mb-3">
            <button class="btn btn-run-all text-white" onclick="runAllTests()">
                <i class="bi bi-lightning-charge-fill me-2"></i>Run All Tests
            </button>
        </div>
        
        <div class="row mb-2">
            <div class="col-12">
                <p class="text-muted mb-0" style="font-size: 0.9rem;">Click on any test to run it individually, or run all tests at once.</p>
            </div>
        </div>
        
        <div class="row g-4 mb-4" id="test-cards-container">
            <!-- Test cards will be dynamically generated here -->
        </div>
        
        <div id="results-panel" class="results-panel">
            <h2 class="mb-4">
                <i class="bi bi-clipboard-data me-2"></i>Test Results
            </h2>
            <div id="summary"></div>
            <div id="results"></div>
        </div>
    </div>
    
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <!-- DataTables JS -->
    <script src="https://code.jquery.com/jquery-3.7.0.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.7/js/jquery.dataTables.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.7/js/dataTables.bootstrap5.min.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.4.2/js/dataTables.buttons.min.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.4.2/js/buttons.bootstrap5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/pdfmake.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/vfs_fonts.js"></script>
    <!-- DataTables Auto-Init (for tables not manually initialized) -->
    <script src="/static/js/datatables-auto-init.js"></script>
    <script>
        // Load test status indicators when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadTestStatusIndicators();
        });
    </script>
    <script src="/static/js/server-timer.js"></script>
    <script>
        // Test metadata with grouping information
        const testMetadata = {
            'date-variations': {
                name: 'Test All Dates',
                icon: 'bi-calendar-event',
                description: 'Tests all date scenarios (today, tomorrow, 3 days, 7 days, 14 days, 30 days, etc.)',
                badge: { text: 'Date Logic', class: 'bg-primary' },
                category: 'Date Logic',
                type: 'Logic',
                component: 'Core Engine'
            },
            'expiration-calc': {
                name: 'Deposit Booking Deadline',
                icon: 'bi-clock-history',
                description: 'Calculates how soon we need the deposit from them to book the staffing reservation. Tests the deposit deadline response for different values of days until event.',
                badge: { text: 'Booking', class: 'bg-primary' },
                category: 'Booking',
                type: 'Calculation',
                component: 'Core Engine'
            },
            'urgency-levels': {
                name: 'Urgency Level Test',
                icon: 'bi-exclamation-triangle',
                description: 'Tests urgency level calculations (critical, urgent, high, moderate, normal)',
                badge: { text: 'Urgency', class: 'bg-primary' },
                category: 'Urgency',
                type: 'Logic',
                component: 'Core Engine'
            },
            'deposit-calc': {
                name: 'Deposit Calculation',
                icon: 'bi-cash-coin',
                description: 'Tests deposit amount calculations for different total costs',
                badge: { text: 'Pricing', class: 'bg-primary' },
                category: 'Pricing',
                type: 'Calculation',
                component: 'Core Engine'
            },
            'pricing-rates': {
                name: 'Pricing & Rates',
                icon: 'bi-currency-dollar',
                description: 'Tests base rates, hourly rates, and special date pricing',
                badge: { text: 'Pricing', class: 'bg-primary' },
                category: 'Pricing',
                type: 'Calculation',
                component: 'Core Engine'
            },
            'email-template': {
                name: 'Email Template',
                icon: 'bi-envelope-fill',
                description: 'Tests email HTML generation with various data combinations',
                badge: { text: 'Email', class: 'bg-primary' },
                category: 'Email',
                type: 'Template',
                component: 'UI/Output'
            },
            'arrival-time': {
                name: 'Arrival Time',
                icon: 'bi-clock-history',
                description: 'Validates arrival time calculation (0.5-1 hour before event)',
                badge: { text: 'New', class: 'bg-success' },
                category: 'Time',
                type: 'Calculation',
                component: 'Core Engine'
            },
            'weather-forecast': {
                name: 'Weather Forecast',
                icon: 'bi-cloud-sun',
                description: 'Tests weather fetching for events < 10 days away',
                badge: { text: 'Weather', class: 'bg-primary' },
                category: 'Weather',
                type: 'Display',
                component: 'External Services'
            },
            'form-validation': {
                name: 'Form Validation',
                icon: 'bi-check-circle',
                description: 'Tests all form field validations and edge cases',
                badge: { text: 'Validation', class: 'bg-primary' },
                category: 'Validation',
                type: 'Validation',
                component: 'UI/Output'
            },
            'special-dates': {
                name: 'Show All Holidays',
                icon: 'bi-calendar-check',
                description: 'Shows all holiday dates 3 years forward. Config: <code>estimate.go</code> → <code>GetHolidayDatesForYear()</code>',
                badge: { text: 'Holidays', class: 'bg-success' },
                category: 'Dates',
                type: 'Display',
                component: 'External Services'
            },
            'surge-dates': {
                name: 'Show All Surge',
                icon: 'bi-graph-up-arrow',
                description: 'Shows all surge dates 3 years forward. Config: <code>estimate.go</code> → <code>surgeDateRules</code> map',
                badge: { text: 'Surge', class: 'bg-warning text-dark' },
                category: 'Dates',
                type: 'Display',
                component: 'External Services'
            }
        };
        
        // Grouping mode state
        let currentGroupMode = 'category'; // Default: category
        let activeFilter = null; // null means show all
        let activeStatusFilter = 'all'; // 'all', 'pass', 'warning', 'fail', 'none'
        
        // Calculate status counts from localStorage
        function getStatusCounts() {
            const counts = {
                all: Object.keys(testMetadata).length,
                pass: 0,
                warning: 0,
                fail: 0,
                none: 0
            };
            
            Object.keys(testMetadata).forEach(testId => {
                const stored = localStorage.getItem(`test_result_${testId}`);
                let status = 'none';
                
                if (stored) {
                    try {
                        const testResult = JSON.parse(stored);
                        if (testResult.failed > 0) {
                            status = 'fail';
                        } else if (testResult.warnings > 0) {
                            status = 'warning';
                        } else if (testResult.passed > 0 && testResult.total > 0) {
                            status = 'pass';
                        }
                    } catch (e) {
                        console.error(`Error parsing stored result for ${testId}:`, e);
                    }
                }
                
                if (status !== 'none') {
                    counts[status]++;
                } else {
                    counts.none++;
                }
            });
            
            return counts;
        }
        
        // Calculate group counts for current grouping mode
        function getGroupCounts(mode) {
            const groups = groupTests(mode);
            const counts = {};
            
            Object.keys(groups).forEach(groupName => {
                counts[groupName] = groups[groupName].length;
            });
            
            return counts;
        }
        
        // Update status filter buttons with counts
        function updateStatusFilterButtons() {
            const counts = getStatusCounts();
            const buttons = document.querySelectorAll('.status-filter');
            
            buttons.forEach(btn => {
                const status = btn.getAttribute('data-status-filter');
                const icon = btn.querySelector('i');
                if (!icon) return;
                
                const iconClass = icon.className;
                
                let count = 0;
                let label = '';
                if (status === 'all') {
                    count = counts.all;
                    label = 'All';
                } else if (status === 'pass') {
                    count = counts.pass;
                    label = 'Passed';
                } else if (status === 'warning') {
                    count = counts.warning;
                    label = 'Warning';
                } else if (status === 'fail') {
                    count = counts.fail;
                    label = 'Failed';
                } else if (status === 'none') {
                    count = counts.none;
                    label = 'Not Run';
                }
                
                // Update button text while preserving icon
                icon.className = iconClass;
                btn.innerHTML = `<i class="${iconClass}"></i>${label} (${count})`;
            });
        }
        
        // Update group by buttons with counts
        function updateGroupByButtons() {
            const categoryCounts = getGroupCounts('category');
            const typeCounts = getGroupCounts('type');
            const componentCounts = getGroupCounts('component');
            
            // Update Category button
            const categoryBtn = document.querySelector('.filter-btn[data-group-mode="category"]');
            if (categoryBtn) {
                const icon = categoryBtn.querySelector('i');
                if (icon) {
                    const iconClass = icon.className;
                    categoryBtn.innerHTML = `<i class="${iconClass}"></i>Category (${Object.keys(categoryCounts).length})`;
                }
            }
            
            // Update Test Type button
            const typeBtn = document.querySelector('.filter-btn[data-group-mode="type"]');
            if (typeBtn) {
                const icon = typeBtn.querySelector('i');
                if (icon) {
                    const iconClass = icon.className;
                    typeBtn.innerHTML = `<i class="${iconClass}"></i>Test Type (${Object.keys(typeCounts).length})`;
                }
            }
            
            // Update Component button
            const componentBtn = document.querySelector('.filter-btn[data-group-mode="component"]');
            if (componentBtn) {
                const icon = componentBtn.querySelector('i');
                if (icon) {
                    const iconClass = icon.className;
                    componentBtn.innerHTML = `<i class="${iconClass}"></i>Component (${Object.keys(componentCounts).length})`;
                }
            }
        }
        
        // Initialize test cards on page load
        document.addEventListener('DOMContentLoaded', function() {
            renderTestCards();
            updateFilterTags();
            loadTestStatusIndicators();
            restoreExpandedStates();
            updateStatusFilterButtons();
            updateGroupByButtons();
        });
        
        // Restore expanded states from localStorage
        function restoreExpandedStates() {
            const testNames = [
                'date-variations',
                'expiration-calc',
                'urgency-levels',
                'deposit-calc',
                'pricing-rates',
                'email-template',
                'arrival-time',
                'weather-forecast',
                'form-validation',
                'special-dates',
                'surge-dates'
            ];
            
            testNames.forEach(testName => {
                const isExpanded = localStorage.getItem(`test_expanded_${testName}`) === 'true';
                const resultsContainer = document.getElementById(`test-results-${testName}`);
                if (resultsContainer) {
                    // Set display state
                    resultsContainer.style.display = isExpanded ? 'block' : 'none';
                    // Update button to reflect actual state
                    updateCollapseButton(testName, isExpanded);
                    
                    if (isExpanded) {
                        // Restore test results if they exist in localStorage
                        const stored = localStorage.getItem(`test_result_${testName}`);
                        if (stored) {
                            try {
                                const testResult = JSON.parse(stored);
                                // Reconstruct the data object from stored result
                                const data = {
                                    total: testResult.total || 0,
                                    passed: testResult.passed || 0,
                                    failed: testResult.failed || 0,
                                    warnings: testResult.warnings || 0,
                                    results: testResult.results || []
                                };
                                // Display the results inline
                                displayInlineResults(data, testName);
                            } catch (e) {
                                console.error(`Error restoring results for ${testName}:`, e);
                            }
                        }
                    }
                }
            });
        }
        
        // Render test cards based on current grouping mode and filter
        function renderTestCards() {
            const container = document.getElementById('test-cards-container');
            if (!container) return;
            
            // Helper function to get test status
            function getTestStatus(testId) {
                const stored = localStorage.getItem(`test_result_${testId}`);
                let testStatus = 'none'; // 'none', 'pass', 'warning', 'fail'
                if (stored) {
                    try {
                        const testResult = JSON.parse(stored);
                        if (testResult.failed > 0) {
                            testStatus = 'fail';
                        } else if (testResult.warnings > 0) {
                            testStatus = 'warning';
                        } else if (testResult.passed > 0 && testResult.total > 0) {
                            testStatus = 'pass';
                        }
                    } catch (e) {
                        console.error(`Error parsing stored result for ${testId}:`, e);
                    }
                }
                return testStatus;
            }
            
            // First, filter tests by status filter
            const allTestIds = Object.keys(testMetadata);
            const statusFilteredTests = allTestIds.filter(testId => {
                if (activeStatusFilter === 'all') return true;
                const testStatus = getTestStatus(testId);
                return testStatus === activeStatusFilter;
            });
            
            // Group the filtered tests by current mode
            const groups = {};
            statusFilteredTests.forEach(testId => {
                const test = testMetadata[testId];
                if (!test) return;
                
                let groupName;
                switch(currentGroupMode) {
                    case 'category':
                        groupName = test.category;
                        break;
                    case 'type':
                        groupName = test.type;
                        break;
                    case 'component':
                        groupName = test.component;
                        break;
                    default:
                        groupName = 'All Tests';
                }
                
                if (!groups[groupName]) {
                    groups[groupName] = [];
                }
                groups[groupName].push(testId);
            });
            
            // If a filter is active, only show groups that match
            const filteredGroups = activeFilter 
                ? Object.keys(groups).filter(group => group === activeFilter)
                : Object.keys(groups);
            
            let html = '';
            
            filteredGroups.forEach(groupName => {
                const tests = groups[groupName];
                if (tests.length === 0) return; // Skip empty groups
                
                // Group header (only show if grouping is enabled and not filtering)
                if (currentGroupMode !== 'none' && !activeFilter) {
                    html += `<div class="col-12"><div class="group-header">${groupName}</div></div>`;
                }
                
                // Sort tests within group for consistent ordering
                tests.sort();
                
                // Test cards
                tests.forEach(testId => {
                    const test = testMetadata[testId];
                    if (!test) return;
                    
                    const testStatus = getTestStatus(testId);
                    
                    // Check if test has been run (has results in localStorage)
                    const hasResults = localStorage.getItem(`test_result_${testId}`) !== null;
                    const isExpanded = hasResults && localStorage.getItem(`test_expanded_${testId}`) === 'true';
                    
                    html += `
                        <div class="col-md-6 col-lg-4 test-card-wrapper" data-test-id="${testId}" data-category="${test.category}" data-type="${test.type}" data-component="${test.component}" data-test-status="${testStatus}">
                            <div class="card test-card">
                                <div class="card-body text-center p-4" style="cursor: pointer;" onclick="runTest('${testId}')">
                                    <i class="bi ${test.icon} card-icon"></i>
                                    <h5 class="card-title mb-2">${test.name}</h5>
                                    <p class="card-text text-muted" style="font-size: 0.85rem; line-height: 1.4;">${test.description}</p>
                                    <span class="badge ${test.badge.class}">${test.badge.text}</span>
                                </div>
                                <div class="test-status-indicator" data-test-name="${testId}"></div>
                            </div>
                        </div>
                        ${hasResults ? `
                        <div class="col-12 test-results-container" id="test-results-${testId}" style="display: ${isExpanded ? 'block' : 'none'};">
                            <div class="card mt-3">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <h6 class="mb-0"><i class="bi bi-clipboard-data me-2"></i>Test Results: ${test.name}</h6>
                                    <button class="btn btn-sm btn-outline-secondary collapse-toggle-btn" onclick="toggleTestResults('${testId}')" id="collapse-btn-${testId}">
                                        ${isExpanded ? '<i class="bi bi-chevron-up"></i> Collapse' : '<i class="bi bi-chevron-down"></i> Expand'}
                                    </button>
                                </div>
                                <div class="card-body">
                                    <div id="test-summary-${testId}"></div>
                                    <div id="test-results-content-${testId}"></div>
                                </div>
                            </div>
                        </div>
                        ` : ''}
                    `;
                });
            });
            
            container.innerHTML = html;
            
            // Re-apply status indicators after rendering
            setTimeout(() => {
                loadTestStatusIndicators();
            }, 100);
        }
        
        // Group tests by the specified mode
        function groupTests(mode) {
            const groups = {};
            
            Object.keys(testMetadata).forEach(testId => {
                let groupName;
                switch(mode) {
                    case 'category':
                        groupName = testMetadata[testId].category;
                        break;
                    case 'type':
                        groupName = testMetadata[testId].type;
                        break;
                    case 'component':
                        groupName = testMetadata[testId].component;
                        break;
                    default:
                        groupName = 'All Tests';
                }
                
                if (!groups[groupName]) {
                    groups[groupName] = [];
                }
                groups[groupName].push(testId);
            });
            
            // Sort groups and tests within groups
            const sortedGroups = {};
            Object.keys(groups).sort().forEach(key => {
                sortedGroups[key] = groups[key].sort();
            });
            
            return sortedGroups;
        }
        
        // Set grouping mode
        function setGroupMode(mode) {
            currentGroupMode = mode;
            activeFilter = null; // Reset filter when changing mode
            
            // Update active button
            document.querySelectorAll('.filter-btn[data-group-mode]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.filter-btn[data-group-mode="${mode}"]`).classList.add('active');
            
            renderTestCards();
            updateFilterTags();
            updateGroupByButtons();
        }
        
        // Update filter tags based on current grouping mode
        function updateFilterTags() {
            const container = document.getElementById('filter-tags-container');
            if (!container) return;
            
            const groups = groupTests(currentGroupMode);
            const groupNames = Object.keys(groups).sort();
            
            let html = '<span class="filter-label"><i class="bi bi-funnel-fill me-1"></i>Filter:</span>';
            html += `<button class="filter-btn ${activeFilter === null ? 'active' : ''}" onclick="setFilter(null)">All (${Object.keys(testMetadata).length})</button>`;
            
            groupNames.forEach(groupName => {
                const count = groups[groupName].length;
                html += `<button class="filter-btn ${activeFilter === groupName ? 'active' : ''}" onclick="setFilter('${groupName}')">${groupName} (${count})</button>`;
            });
            
            container.innerHTML = html;
        }
        
        // Set active filter
        function setFilter(filterName) {
            activeFilter = filterName;
            updateFilterTags();
            renderTestCards();
        }
        
        // Set status filter
        function setStatusFilter(status) {
            activeStatusFilter = status;
            
            // Update active button
            document.querySelectorAll('.status-filter').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.status-filter[data-status-filter="${status}"]`).classList.add('active');
            
            // Apply filter to existing cards
            const cardWrappers = document.querySelectorAll('.test-card-wrapper');
            cardWrappers.forEach(card => {
                const cardStatus = card.getAttribute('data-test-status') || 'none';
                if (status === 'all' || cardStatus === status) {
                    card.style.display = '';
                } else {
                    card.style.display = 'none';
                }
            });
            
            // Also re-render to ensure consistency
            renderTestCards();
        }
        
        async function runTest(testName) {
            // Get inline results containers
            const resultsContainer = document.getElementById(`test-results-${testName}`);
            const resultsDiv = document.getElementById(`test-results-content-${testName}`);
            const summaryDiv = document.getElementById(`test-summary-${testName}`);
            
            // Show and expand the results container
            if (resultsContainer) {
                resultsContainer.style.display = 'block';
                localStorage.setItem(`test_expanded_${testName}`, 'true');
                updateCollapseButton(testName, true);
            }
            
            // Show loading state
            if (resultsDiv) {
                resultsDiv.innerHTML = '<div class="loading text-center p-4"><i class="bi bi-arrow-repeat"></i><p class="mt-3">Running test... Please wait.</p></div>';
            }
            if (summaryDiv) {
                summaryDiv.innerHTML = '';
            }
            
            // Scroll to the test card
            const testCard = document.querySelector(`.test-card-wrapper[data-test-id="${testName}"]`);
            if (testCard) {
                testCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            
            try {
                const response = await fetch(`/api/test/${testName}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        dateRange: 'all',
                        detailed: true,
                        generateReport: true
                    })
                });
                
                const data = await response.json();
                displayInlineResults(data, testName);
            } catch (error) {
                if (resultsDiv) {
                    resultsDiv.innerHTML = `
                        <div class="alert alert-danger">
                            <h5><i class="bi bi-x-circle me-2"></i>Error</h5>
                            <p>Failed to run test: ${error.message}</p>
                        </div>
                    `;
                }
            }
        }
        
        function toggleTestResults(testName) {
            const resultsContainer = document.getElementById(`test-results-${testName}`);
            if (!resultsContainer) {
                console.warn(`Results container not found for test: ${testName}`);
                return;
            }
            
            // Check current state - consider both inline style and computed style
            const currentDisplay = resultsContainer.style.display;
            const computedDisplay = window.getComputedStyle(resultsContainer).display;
            const isCurrentlyExpanded = currentDisplay !== 'none' && computedDisplay !== 'none';
            const newState = !isCurrentlyExpanded;
            
            resultsContainer.style.display = newState ? 'block' : 'none';
            localStorage.setItem(`test_expanded_${testName}`, newState.toString());
            updateCollapseButton(testName, newState);
            
            // Scroll to the results if expanding
            if (newState) {
                setTimeout(() => {
                    resultsContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
            }
        }
        
        function updateCollapseButton(testName, isExpanded) {
            const button = document.getElementById(`collapse-btn-${testName}`);
            if (button) {
                if (isExpanded) {
                    button.innerHTML = '<i class="bi bi-chevron-up"></i> Collapse';
                } else {
                    button.innerHTML = '<i class="bi bi-chevron-down"></i> Expand';
                }
            }
        }
        
        async function runAllTests() {
            const resultsPanel = document.getElementById('results-panel');
            const resultsDiv = document.getElementById('results');
            const summaryDiv = document.getElementById('summary');
            
            resultsPanel.classList.add('active');
            resultsDiv.innerHTML = '<div class="loading"><i class="bi bi-arrow-repeat"></i><p class="mt-3">Running all tests... This may take a moment.</p></div>';
            summaryDiv.innerHTML = '';
            
            // List of all test names
            const testNames = [
                'date-variations',
                'expiration-calc',
                'urgency-levels',
                'deposit-calc',
                'pricing-rates',
                'email-template',
                'arrival-time',
                'weather-forecast',
                'form-validation',
                'special-dates',
                'surge-dates'
            ];
            
            try {
                // Run all tests individually to store their results properly
                const testPromises = testNames.map(async (testName) => {
                    try {
                        const response = await fetch(`/api/test/${testName}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                dateRange: 'all',
                                detailed: true,
                                generateReport: true
                            })
                        });
                        const data = await response.json();
                        // Store each test result immediately
                        storeTestResult(testName, data);
                        return data;
                    } catch (error) {
                        console.error(`Error running test ${testName}:`, error);
                        // Store error result
                        storeTestResult(testName, {
                            passed: 0,
                            failed: 1,
                            warnings: 0,
                            total: 1
                        });
                        return null;
                    }
                });
                
                // Wait for all tests to complete
                const allResults = await Promise.all(testPromises);
                
                // Calculate combined totals
                const combined = {
                    total: 0,
                    passed: 0,
                    failed: 0,
                    warnings: 0,
                    results: []
                };
                
                allResults.forEach(result => {
                    if (result) {
                        combined.total += result.total || 0;
                        combined.passed += result.passed || 0;
                        combined.failed += result.failed || 0;
                        combined.warnings += result.warnings || 0;
                        if (result.results) {
                            combined.results = combined.results.concat(result.results);
                        }
                    }
                });
                
                // Display combined results
                displayResults(combined, 'All Tests');
            } catch (error) {
                resultsDiv.innerHTML = `
                    <div class="test-result error">
                        <h5><i class="bi bi-x-circle me-2"></i>Error</h5>
                        <p>Failed to run tests: ${error.message}</p>
                    </div>
                `;
            }
        }
        
        // Store test result in localStorage
        function storeTestResult(testName, result) {
            const testResult = {
                testName: testName,
                passed: result.passed || 0,
                failed: result.failed || 0,
                warnings: result.warnings || 0,
                total: result.total || 0,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem(`test_result_${testName}`, JSON.stringify(testResult));
            updateTestStatusIndicator(testName, testResult);
        }
        
        // Update status indicator for a test
        function updateTestStatusIndicator(testName, testResult) {
            const indicator = document.querySelector(`.test-status-indicator[data-test-name="${testName}"]`);
            const cardWrapper = document.querySelector(`.test-card-wrapper[data-test-id="${testName}"]`);
            
            // Determine status based on results (priority: failed > warnings > passed)
            let status = 'none';
            if (testResult.failed > 0) {
                status = 'fail';
            } else if (testResult.warnings > 0) {
                status = 'warning';
            } else if (testResult.passed > 0 && testResult.total > 0) {
                status = 'pass';
            }
            
            // Update indicator
            if (indicator) {
                // Remove existing status classes
                indicator.classList.remove('status-pass', 'status-fail', 'status-warning');
                
                if (status === 'fail') {
                    indicator.classList.add('status-fail');
                } else if (status === 'warning') {
                    indicator.classList.add('status-warning');
                } else if (status === 'pass') {
                    indicator.classList.add('status-pass');
                }
            }
            
            // Update card wrapper data attribute for filtering
            if (cardWrapper) {
                cardWrapper.setAttribute('data-test-status', status);
                
                // Apply status filter if active
                if (activeStatusFilter !== 'all' && status !== activeStatusFilter) {
                    cardWrapper.style.display = 'none';
                } else {
                    cardWrapper.style.display = '';
                }
            }
            
            // Update status filter button counts
            updateStatusFilterButtons();
        }
        
        // Load and display all test status indicators on page load
        function loadTestStatusIndicators() {
            const testNames = [
                'date-variations',
                'expiration-calc',
                'urgency-levels',
                'deposit-calc',
                'pricing-rates',
                'email-template',
                'arrival-time',
                'weather-forecast',
                'form-validation',
                'special-dates',
                'surge-dates'
            ];
            
            testNames.forEach(testName => {
                const stored = localStorage.getItem(`test_result_${testName}`);
                if (stored) {
                    try {
                        const testResult = JSON.parse(stored);
                        updateTestStatusIndicator(testName, testResult);
                    } catch (e) {
                        console.error(`Error parsing stored result for ${testName}:`, e);
                    }
                } else {
                    // Set status to 'none' for tests that haven't been run
                    const cardWrapper = document.querySelector(`.test-card-wrapper[data-test-id="${testName}"]`);
                    if (cardWrapper) {
                        cardWrapper.setAttribute('data-test-status', 'none');
                        // Apply status filter
                        if (activeStatusFilter !== 'all' && activeStatusFilter !== 'none') {
                            cardWrapper.style.display = 'none';
                        }
                    }
                }
            });
            
            // Update status filter button counts after loading all indicators
            updateStatusFilterButtons();
        }
        
        // View mode state
        let currentViewMode = 'simplified'; // Default to simplified
        
        function displayInlineResults(data, testName) {
            const resultsDiv = document.getElementById(`test-results-content-${testName}`);
            const summaryDiv = document.getElementById(`test-summary-${testName}`);
            
            // Store test result
            storeTestResult(testName, data);
            
            // Summary
            const total = data.total || 0;
            const passed = data.passed || 0;
            const failed = data.failed || 0;
            const warnings = data.warnings || 0;
            
            const summaryClass = failed > 0 ? 'error' : '';
            const summaryIcon = failed > 0 ? 'bi-x-circle' : 'bi-check-circle';
            
            // View toggle buttons
            const viewToggle = `
                <div class="btn-group mb-3" role="group">
                    <button type="button" class="btn btn-sm ${currentViewMode === 'simplified' ? 'btn-primary' : 'btn-outline-primary'}" onclick="switchInlineView('simplified', '${testName}')">
                        <i class="bi bi-list-ul me-1"></i>Simplified
                    </button>
                    <button type="button" class="btn btn-sm ${currentViewMode === 'advanced' ? 'btn-primary' : 'btn-outline-primary'}" onclick="switchInlineView('advanced', '${testName}')">
                        <i class="bi bi-code-square me-1"></i>Advanced
                    </button>
                </div>
            `;
            
            if (summaryDiv) {
                summaryDiv.innerHTML = `
                    <div class="summary ${summaryClass} mb-3">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0"><i class="bi ${summaryIcon} me-2"></i>Test Summary: ${testName}</h6>
                            ${viewToggle}
                        </div>
                        <div class="row">
                            <div class="col-md-3">
                                <strong>Total:</strong> <span class="badge bg-secondary">${total}</span>
                            </div>
                            <div class="col-md-3">
                                <strong style="color: #4caf50;">Passed:</strong> <span class="badge bg-success">${passed}</span>
                            </div>
                            <div class="col-md-3">
                                <strong style="color: #f44336;">Failed:</strong> <span class="badge bg-danger">${failed}</span>
                            </div>
                            <div class="col-md-3">
                                <strong style="color: #ff9800;">Warnings:</strong> <span class="badge bg-warning">${warnings}</span>
                            </div>
                        </div>
                        ${data.reportUrl ? `<p class="mt-3 mb-0"><a href="${data.reportUrl}" target="_blank" class="btn btn-sm btn-outline-primary"><i class="bi bi-file-earmark-text me-2"></i>View Detailed Report</a></p>` : ''}
                    </div>
                `;
            }
            
            // Store data for view switching
            if (!window.testDataCache) {
                window.testDataCache = {};
            }
            window.testDataCache[testName] = data;
            
            // Display based on current view mode
            if (resultsDiv) {
                if (currentViewMode === 'simplified') {
                    displaySimplifiedView(data, testName, resultsDiv);
                } else {
                    displayAdvancedView(data, testName, resultsDiv);
                }
            }
        }
        
        function switchInlineView(mode, testName) {
            currentViewMode = mode;
            if (window.testDataCache && window.testDataCache[testName]) {
                const resultsDiv = document.getElementById(`test-results-content-${testName}`);
                if (resultsDiv) {
                    if (mode === 'simplified') {
                        displaySimplifiedView(window.testDataCache[testName], testName, resultsDiv);
                    } else {
                        displayAdvancedView(window.testDataCache[testName], testName, resultsDiv);
                    }
                }
            }
        }
        
        // Keep the old displayResults for backward compatibility (if results panel is still used)
        function displayResults(data, testName) {
            displayInlineResults(data, testName);
        }
        
        function switchView(mode, testName) {
            switchInlineView(mode, testName);
        }
        
        function displaySimplifiedView(data, testName, resultsDiv) {
            if (testName === 'date-variations') {
                displaySimplifiedDateVariations(data, resultsDiv);
            } else if (testName === 'expiration-calc') {
                displaySimplifiedExpirationCalc(data, resultsDiv);
            } else if (testName === 'special-dates') {
                displaySimplifiedSpecialDates(data, resultsDiv);
            } else if (testName === 'surge-dates') {
                displaySimplifiedSurgeDates(data, resultsDiv);
            } else if (testName === 'weather-forecast') {
                displaySimplifiedWeatherForecast(data, resultsDiv);
            } else if (testName === 'pricing-rates') {
                displaySimplifiedPricingRates(data, resultsDiv);
            } else {
                // Fallback to advanced for other tests
                displayAdvancedView(data, testName, resultsDiv);
            }
        }
        
        function displaySimplifiedExpirationCalc(data, resultsDiv) {
            if (!data.results || data.results.length === 0) {
                resultsDiv.innerHTML = '<div class="alert alert-info">No deposit booking deadline test results available.</div>';
                return;
            }
            
            const tableData = data.results.map(result => {
                const daysUntilEvent = result.data?.daysUntilEvent ?? 0;
                const expirationFormatted = result.data?.expirationFormatted || 'N/A';
                const expirationDate = result.data?.expirationDate || 'N/A';
                const expectedRule = result.expected || '';
                
                // Determine deadline category for better understanding
                let deadlineCategory = '';
                if (daysUntilEvent === 0) {
                    deadlineCategory = 'Immediate';
                } else if (daysUntilEvent <= 3) {
                    deadlineCategory = 'Today';
                } else if (daysUntilEvent <= 7) {
                    deadlineCategory = '48 Hours';
                } else if (daysUntilEvent <= 14) {
                    deadlineCategory = '3 Days';
                } else {
                    deadlineCategory = '2 Weeks';
                }
                
                return {
                    daysUntilEvent: daysUntilEvent,
                    deadlineCategory: deadlineCategory,
                    expectedRule: expectedRule,
                    expirationFormatted: expirationFormatted,
                    expirationDate: expirationDate,
                    status: result.status,
                    message: result.message || ''
                };
            });
            
            // Sort by days until event
            tableData.sort((a, b) => a.daysUntilEvent - b.daysUntilEvent);
            
            const tableHTML = `
                <div class="table-responsive">
                    <table id="expirationCalcTable" class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>Days Until Event</th>
                                <th>Deadline Category</th>
                                <th>Expected Rule</th>
                                <th>Deposit Deadline</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableData.map(row => `
                                <tr class="${row.status === 'pass' ? '' : row.status === 'warning' ? 'table-warning' : 'table-danger'}">
                                    <td><strong>${row.daysUntilEvent}</strong></td>
                                    <td><span class="badge bg-info">${row.deadlineCategory}</span></td>
                                    <td>${row.expectedRule}</td>
                                    <td>${row.expirationFormatted}</td>
                                    <td>
                                        <span class="badge bg-${row.status === 'pass' ? 'success' : row.status === 'warning' ? 'warning' : 'danger'}">${row.status}</span>
                                        ${row.message ? `<br><small class="text-muted">${row.message}</small>` : ''}
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            resultsDiv.innerHTML = tableHTML;
            
            // Initialize DataTable
            setTimeout(() => {
                if ($.fn.DataTable.isDataTable('#expirationCalcTable')) {
                    $('#expirationCalcTable').DataTable().destroy();
                }
                $('#expirationCalcTable').DataTable({
                    pageLength: 25,
                    order: [[0, 'asc']],
                    dom: 'Bfrtip',
                    buttons: ['copy', 'csv', 'excel'],
                    language: {
                        search: "Filter by days or category:"
                    }
                });
            }, 100);
        }
        
        function displaySimplifiedDateVariations(data, resultsDiv) {
            if (!data.results || data.results.length === 0) {
                resultsDiv.innerHTML = '<div class="alert alert-info">No date variation test results available.</div>';
                return;
            }
            
            const tableData = data.results.map(result => {
                const daysUntilEvent = result.data?.daysUntilEvent ?? 0;
                const urgencyLevel = result.data?.urgencyLevel || 'unknown';
                const expirationFormatted = result.data?.expirationFormatted || 'N/A';
                const expirationDate = result.data?.expirationDate || 'N/A';
                
                // Extract test name (e.g., "Today", "Tomorrow", "2 days from now")
                let testName = result.name || '';
                // Remove the "(X days)" part if present
                testName = testName.replace(/\s*\(\d+\s+days?\)$/, '');
                
                // Get urgency badge color
                let urgencyBadgeClass = 'bg-secondary';
                if (urgencyLevel === 'critical') urgencyBadgeClass = 'bg-danger';
                else if (urgencyLevel === 'urgent') urgencyBadgeClass = 'bg-warning text-dark';
                else if (urgencyLevel === 'high') urgencyBadgeClass = 'bg-info';
                else if (urgencyLevel === 'moderate') urgencyBadgeClass = 'bg-primary';
                else if (urgencyLevel === 'normal') urgencyBadgeClass = 'bg-success';
                
                return {
                    daysUntilEvent: daysUntilEvent,
                    testName: testName,
                    urgencyLevel: urgencyLevel,
                    urgencyBadgeClass: urgencyBadgeClass,
                    expirationFormatted: expirationFormatted,
                    expirationDate: expirationDate,
                    status: result.status,
                    message: result.message || ''
                };
            });
            
            // Sort by days until event
            tableData.sort((a, b) => a.daysUntilEvent - b.daysUntilEvent);
            
            const tableHTML = `
                <div class="table-responsive">
                    <table id="dateVariationsTable" class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>Days Until Event</th>
                                <th>Test Name</th>
                                <th>Urgency Level</th>
                                <th>Expiration Date</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableData.map(row => `
                                <tr class="${row.status === 'pass' ? '' : row.status === 'warning' ? 'table-warning' : 'table-danger'}">
                                    <td><strong>${row.daysUntilEvent}</strong></td>
                                    <td>${row.testName}</td>
                                    <td><span class="badge ${row.urgencyBadgeClass}">${row.urgencyLevel}</span></td>
                                    <td>${row.expirationFormatted}</td>
                                    <td>
                                        <span class="badge bg-${row.status === 'pass' ? 'success' : row.status === 'warning' ? 'warning' : 'danger'}">${row.status}</span>
                                        ${row.message ? `<br><small class="text-muted">${row.message}</small>` : ''}
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            resultsDiv.innerHTML = tableHTML;
            
            // Initialize DataTable
            setTimeout(() => {
                if ($.fn.DataTable.isDataTable('#dateVariationsTable')) {
                    $('#dateVariationsTable').DataTable().destroy();
                }
                $('#dateVariationsTable').DataTable({
                    pageLength: 25,
                    order: [[0, 'asc']],
                    dom: 'Bfrtip',
                    buttons: ['copy', 'csv', 'excel'],
                    language: {
                        search: "Filter by days or name:"
                    }
                });
            }, 100);
        }
        
        function displaySimplifiedSpecialDates(data, resultsDiv) {
            if (!data.results || data.results.length === 0) {
                resultsDiv.innerHTML = '<div class="alert alert-info">No special dates found.</div>';
                return;
            }
            
            // Group by year and get all dates per year
            const yearGroups = {};
            data.results.forEach(result => {
                let year;
                if (result.data?.year) {
                    year = result.data.year;
                } else if (result.data?.date) {
                    year = new Date(result.data.date + 'T00:00:00').getFullYear();
                } else {
                    // Try to extract from name like "New Year's Day (2026-01-01)"
                    const match = result.name.match(/\((\d{4})-\d{2}-\d{2}\)/);
                    year = match ? parseInt(match[1]) : new Date().getFullYear();
                }
                if (!yearGroups[year]) {
                    yearGroups[year] = [];
                }
                yearGroups[year].push(result);
            });
            
            // Get all dates per year, sorted by date
            const tableData = [];
            Object.keys(yearGroups).sort().forEach(year => {
                const dates = yearGroups[year]
                    .map(r => {
                        let dateStr = r.data?.date || '';
                        if (!dateStr) {
                            const match = r.name.match(/\((\d{4}-\d{2}-\d{2})\)/);
                            dateStr = match ? match[1] : '';
                        }
                        return { result: r, dateStr: dateStr };
                    })
                    .filter(d => d.dateStr)
                    .sort((a, b) => a.dateStr.localeCompare(b.dateStr));
                
                dates.forEach(({ result, dateStr }) => {
                    // Parse date for formatting
                    let date = new Date(dateStr + 'T00:00:00');
                    let dayOfWeek = result.data?.dayOfWeek || '';
                    
                    if (isNaN(date.getTime())) {
                        const parts = dateStr.split('-');
                        if (parts.length === 3) {
                            date = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                        }
                    }
                    
                    if (!dayOfWeek && !isNaN(date.getTime())) {
                        dayOfWeek = date.toLocaleDateString('en-US', { weekday: 'short' });
                    }
                    
                    // Calculate base rate based on year
                    const baseRatesByYear = {
                        2025: 275,
                        2026: 300,
                        2027: 325,
                        2028: 400,
                        2029: 475,
                        2030: 550
                    };
                    const baseRate = baseRatesByYear[year] || (year < 2025 ? 275 : 550);
                    
                    tableData.push({
                        date: dateStr,
                        dayOfWeek: dayOfWeek,
                        label: result.data?.label || result.name.split('(')[0]?.trim() || result.name,
                        multiplier: result.data?.multiplier || 2.0,
                        type: result.data?.type || 'holiday',
                        year: year,
                        baseRate: baseRate,
                        status: result.status
                    });
                });
            });
            
            // Add index to each row
            tableData.forEach((row, index) => {
                row.index = index + 1;
            });
            
            const totalCount = tableData.length;
            const totalResults = data.results.length;
            const infoMessage = totalCount < totalResults 
                ? `<div class="alert alert-info mb-3"><i class="bi bi-info-circle me-2"></i><strong>Showing ${totalCount} of ${totalResults} special dates.</strong> Use the table pagination controls below to view all results, or use the search/filter to find specific dates.</div>`
                : `<div class="alert alert-success mb-3"><i class="bi bi-check-circle me-2"></i><strong>Showing all ${totalCount} special dates.</strong> Use the table pagination (25 per page) or search to filter results.</div>`;
            
            const tableHTML = `
                ${infoMessage}
                <div class="table-responsive">
                    <table id="specialDatesTable" class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Date (YYYY-MM-DD)</th>
                                <th>Day</th>
                                <th>Label</th>
                                <th>Base Rate</th>
                                <th>Multiplier</th>
                                <th>Type</th>
                                <th>Year</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableData.map(row => `
                                <tr class="${row.status === 'pass' ? '' : row.status === 'warning' ? 'table-warning' : 'table-danger'}">
                                    <td><strong>${row.index}</strong></td>
                                    <td>${row.date}</td>
                                    <td><strong>${row.dayOfWeek}</strong></td>
                                    <td>${row.label}</td>
                                    <td>$${row.baseRate.toFixed(0)}</td>
                                    <td>${row.multiplier}x</td>
                                    <td><span class="badge bg-${row.type === 'holiday' ? 'success' : 'warning'}">${row.type}</span></td>
                                    <td>${row.year}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            resultsDiv.innerHTML = tableHTML;
            
            // Initialize DataTable
            setTimeout(() => {
                if ($.fn.DataTable.isDataTable('#specialDatesTable')) {
                    $('#specialDatesTable').DataTable().destroy();
                }
                $('#specialDatesTable').DataTable({
                    pageLength: 25,
                    order: [[1, 'asc']], // Sort by date column (now column 1, index is column 0)
                    dom: 'Bfrtip',
                    buttons: ['copy', 'csv', 'excel'],
                    language: {
                        search: "Filter by date:"
                    },
                    columnDefs: [
                        { orderable: false, targets: 0 } // Make index column non-sortable
                    ]
                });
            }, 100);
        }
        
        function displaySimplifiedSurgeDates(data, resultsDiv) {
            if (!data.results || data.results.length === 0) {
                resultsDiv.innerHTML = '<div class="alert alert-info">No surge dates found.</div>';
                return;
            }
            
            // Filter out "No surge dates configured" warnings
            const validResults = data.results.filter(r => r.data?.date);
            
            if (validResults.length === 0) {
                resultsDiv.innerHTML = '<div class="alert alert-warning">No surge dates configured for the next 3 years.</div>';
                return;
            }
            
            // Group by year and get all dates per year
            const yearGroups = {};
            validResults.forEach(result => {
                let year;
                if (result.data?.year) {
                    year = result.data.year;
                } else if (result.data?.date) {
                    year = new Date(result.data.date + 'T00:00:00').getFullYear();
                } else {
                    // Try to extract from name like "February Surge (2026-02-05)"
                    const match = result.name.match(/\((\d{4})-\d{2}-\d{2}\)/);
                    year = match ? parseInt(match[1]) : new Date().getFullYear();
                }
                if (!yearGroups[year]) {
                    yearGroups[year] = [];
                }
                yearGroups[year].push(result);
            });
            
            // Get all dates per year, sorted by date
            const tableData = [];
            Object.keys(yearGroups).sort().forEach(year => {
                const dates = yearGroups[year]
                    .map(r => {
                        let dateStr = r.data?.date || '';
                        if (!dateStr) {
                            const match = r.name.match(/\((\d{4}-\d{2}-\d{2})\)/);
                            dateStr = match ? match[1] : '';
                        }
                        return { result: r, dateStr: dateStr };
                    })
                    .filter(d => d.dateStr)
                    .sort((a, b) => a.dateStr.localeCompare(b.dateStr));
                
                dates.forEach(({ result, dateStr }) => {
                    // Parse date for formatting
                    let date = new Date(dateStr + 'T00:00:00');
                    let dateMMDDYYYY = result.data?.dateMMDDYYYY || '';
                    let dayOfWeek = result.data?.dayOfWeek || '';
                    
                    if (isNaN(date.getTime())) {
                        const parts = dateStr.split('-');
                        if (parts.length === 3) {
                            date = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                        }
                    }
                    
                    if (!dateMMDDYYYY && !isNaN(date.getTime())) {
                        const month = String(date.getMonth() + 1).padStart(2, '0');
                        const day = String(date.getDate()).padStart(2, '0');
                        dateMMDDYYYY = `${month}/${day}/${date.getFullYear()}`;
                    }
                    
                    if (!dayOfWeek && !isNaN(date.getTime())) {
                        dayOfWeek = date.toLocaleDateString('en-US', { weekday: 'short' });
                    }
                    
                    tableData.push({
                        date: dateStr,
                        dateMMDDYYYY: dateMMDDYYYY,
                        dayOfWeek: dayOfWeek,
                        label: result.data?.label || result.name.split('(')[0]?.trim() || result.name,
                        multiplier: result.data?.multiplier || 1.5,
                        type: result.data?.type || 'surge',
                        year: year,
                        status: result.status
                    });
                });
            });
            
            // Add index to each row
            tableData.forEach((row, index) => {
                row.index = index + 1;
            });
            
            const totalCount = tableData.length;
            const totalResults = validResults.length;
            const infoMessage = totalCount < totalResults 
                ? `<div class="alert alert-info mb-3"><i class="bi bi-info-circle me-2"></i><strong>Showing ${totalCount} of ${totalResults} surge dates.</strong> Use the table pagination controls below to view all results, or use the search/filter to find specific dates.</div>`
                : `<div class="alert alert-success mb-3"><i class="bi bi-check-circle me-2"></i><strong>Showing all ${totalCount} surge dates.</strong> Use the table pagination (25 per page) or search to filter results.</div>`;
            
            const tableHTML = `
                ${infoMessage}
                <div class="table-responsive">
                    <table id="surgeDatesTable" class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Date (YYYY-MM-DD)</th>
                                <th>Date (MM/DD/YYYY)</th>
                                <th>Day</th>
                                <th>Label</th>
                                <th>Multiplier</th>
                                <th>Type</th>
                                <th>Year</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableData.map(row => `
                                <tr class="${row.status === 'pass' ? '' : row.status === 'warning' ? 'table-warning' : 'table-danger'}">
                                    <td><strong>${row.index}</strong></td>
                                    <td>${row.date}</td>
                                    <td>${row.dateMMDDYYYY}</td>
                                    <td><strong>${row.dayOfWeek}</strong></td>
                                    <td>${row.label}</td>
                                    <td>${row.multiplier}x</td>
                                    <td><span class="badge bg-warning text-dark">${row.type}</span></td>
                                    <td>${row.year}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            resultsDiv.innerHTML = tableHTML;
            
            // Initialize DataTable
            setTimeout(() => {
                if ($.fn.DataTable.isDataTable('#surgeDatesTable')) {
                    $('#surgeDatesTable').DataTable().destroy();
                }
                $('#surgeDatesTable').DataTable({
                    pageLength: 25,
                    order: [[1, 'asc']], // Sort by date column (now column 1, index is column 0)
                    dom: 'Bfrtip',
                    buttons: ['copy', 'csv', 'excel'],
                    language: {
                        search: "Filter by date:"
                    },
                    columnDefs: [
                        { orderable: false, targets: 0 } // Make index column non-sortable
                    ]
                });
            }, 100);
        }
        
        function displaySimplifiedWeatherForecast(data, resultsDiv) {
            if (!data.results || data.results.length === 0) {
                resultsDiv.innerHTML = '<div class="alert alert-info">No weather forecast data available.</div>';
                return;
            }
            
            const tableData = data.results.map(result => {
                const dateStr = result.data?.date || result.name;
                let date = new Date(dateStr + 'T00:00:00');
                if (isNaN(date.getTime())) {
                    const parts = dateStr.split('-');
                    if (parts.length === 3) {
                        date = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                    } else {
                        date = new Date();
                    }
                }
                return {
                    date: dateStr,
                    dateFormatted: result.data?.dateFormatted || date.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }),
                    dayOfWeek: result.data?.dayOfWeek || date.toLocaleDateString('en-US', { weekday: 'long' }),
                    temperature: result.data?.temperature !== undefined ? result.data.temperature : 'N/A',
                    condition: result.data?.condition || 'N/A',
                    description: result.data?.description || 'N/A',
                    humidity: result.data?.humidity !== undefined ? result.data.humidity : 'N/A',
                    windSpeed: result.data?.windSpeed !== undefined ? result.data.windSpeed : 'N/A',
                    status: result.status,
                    isPlaceholder: result.data?.isPlaceholder || false
                };
            });
            
            const tableHTML = `
                <div class="table-responsive">
                    <table id="weatherForecastTable" class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Day</th>
                                <th>Temperature (°F)</th>
                                <th>Condition</th>
                                <th>Description</th>
                                <th>Humidity (%)</th>
                                <th>Wind Speed (mph)</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableData.map(row => `
                                <tr class="${row.isPlaceholder ? 'table-warning' : row.status === 'pass' ? '' : 'table-danger'}">
                                    <td>${row.date}</td>
                                    <td>${row.dayOfWeek}</td>
                                    <td>${row.temperature}</td>
                                    <td>${row.condition}</td>
                                    <td>${row.description}</td>
                                    <td>${row.humidity}</td>
                                    <td>${row.windSpeed}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            resultsDiv.innerHTML = tableHTML;
            
            // Initialize DataTable
            setTimeout(() => {
                if ($.fn.DataTable.isDataTable('#weatherForecastTable')) {
                    $('#weatherForecastTable').DataTable().destroy();
                }
                $('#weatherForecastTable').DataTable({
                    pageLength: 10,
                    order: [[0, 'asc']],
                    dom: 'Bfrtip',
                    buttons: ['copy', 'csv', 'excel']
                });
            }, 100);
        }
        
        // Pricing rates state
        window.pricingRatesState = {
            selectedYears: new Set(),
            selectedMonths: new Set(), // Format: "YYYY-MM"
            allDaysData: new Map(), // Format: "YYYY-MM-DD" -> data
            baseRatesByYear: {
                2025: 275,
                2026: 300,
                2027: 325,
                2028: 400,
                2029: 475,
                2030: 550
            },
            hourlyRatesByYear: {
                2025: 45,
                2026: 50,
                2027: 55,
                2028: 60,
                2029: 65,
                2030: 70
            }
        };
        
        function displaySimplifiedPricingRates(data, resultsDiv) {
            if (!data.results || data.results.length === 0) {
                resultsDiv.innerHTML = '<div class="alert alert-info">No pricing data available.</div>';
                return;
            }
            
            // Build a map of existing test data by date
            const existingDataMap = new Map();
            data.results.forEach(result => {
                const dateStr = result.data?.date || result.name;
                if (dateStr) {
                    existingDataMap.set(dateStr, {
                        baseRate: result.data?.baseRate || 0,
                        hourlyRate: result.data?.hourlyRate || 0,
                        totalCost: result.data?.totalCost || 0,
                        isSpecialDate: result.data?.isSpecialDate || false,
                        specialLabel: result.data?.specialLabel || '',
                        rateType: result.data?.rateType || '',
                        specialMultiplier: result.data?.specialMultiplier || null
                    });
                }
            });
            
            // Store in global state
            window.pricingRatesState.allDaysData = existingDataMap;
            
            // Get current year and next 2 years (3 years total)
            const now = new Date();
            const currentYear = now.getFullYear();
            const years = [currentYear, currentYear + 1, currentYear + 2];
            
            // Default: select current year and current month
            if (window.pricingRatesState.selectedYears.size === 0) {
                window.pricingRatesState.selectedYears.add(currentYear);
                const currentMonth = String(now.getMonth() + 1).padStart(2, '0');
                window.pricingRatesState.selectedMonths.add(`${currentYear}-${currentMonth}`);
            }
            
            // Generate year/month selector UI
            const yearMonthSelector = generateYearMonthSelector(years);
            
            // Generate all days for selected months
            const allDays = generateAllDaysForSelectedMonths(existingDataMap);
            
            // Ensure at least 31 records
            if (allDays.length < 31) {
                // If less than 31, add more months automatically
                const currentMonth = now.getMonth() + 1;
                for (let i = 0; i < 12 && allDays.length < 31; i++) {
                    const month = ((currentMonth - 1 + i) % 12) + 1;
                    const year = currentYear + Math.floor((currentMonth - 1 + i) / 12);
                    const monthKey = `${year}-${String(month).padStart(2, '0')}`;
                    if (!window.pricingRatesState.selectedMonths.has(monthKey)) {
                        window.pricingRatesState.selectedMonths.add(monthKey);
                        window.pricingRatesState.selectedYears.add(year);
                    }
                }
                // Regenerate with expanded selection
                const expandedDays = generateAllDaysForSelectedMonths(existingDataMap);
                allDays.push(...expandedDays.slice(allDays.length));
            }
            
            const tableHTML = `
                ${yearMonthSelector}
                <div class="table-responsive">
                    <table id="pricingRatesTable" class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Day</th>
                                <th>Base Rate</th>
                                <th>Hourly Rate</th>
                                <th>Total Cost (4h, 2 helpers)</th>
                                <th>Special Date</th>
                                <th>Multiplier</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${allDays.map(row => `
                                <tr class="${row.isSpecialDate ? 'table-info' : ''}">
                                    <td>${row.date}</td>
                                    <td><strong>${row.dayOfWeek}</strong></td>
                                    <td>$${row.baseRate.toFixed(2)}</td>
                                    <td>$${row.hourlyRate.toFixed(2)}</td>
                                    <td>$${row.totalCost.toFixed(2)}</td>
                                    <td>${row.isSpecialDate ? `<span class="badge bg-warning">${row.specialLabel || row.rateType || 'Special'}</span>` : '<span class="text-muted">-</span>'}</td>
                                    <td>${row.specialMultiplier ? `${row.specialMultiplier}x` : '<span class="text-muted">-</span>'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            resultsDiv.innerHTML = tableHTML;
            
            // Initialize DataTable
            setTimeout(() => {
                if ($.fn.DataTable.isDataTable('#pricingRatesTable')) {
                    $('#pricingRatesTable').DataTable().destroy();
                }
                window.pricingTable = $('#pricingRatesTable').DataTable({
                    pageLength: 31, // Always show at least 31 records per page
                    order: [[0, 'asc']],
                    dom: 'Bfrtip',
                    buttons: ['copy', 'csv', 'excel'],
                    language: {
                        search: "Search dates:"
                    }
                });
            }, 100);
        }
        
        function generateYearMonthSelector(years) {
            const months = [
                { value: '01', label: 'Jan' },
                { value: '02', label: 'Feb' },
                { value: '03', label: 'Mar' },
                { value: '04', label: 'Apr' },
                { value: '05', label: 'May' },
                { value: '06', label: 'Jun' },
                { value: '07', label: 'Jul' },
                { value: '08', label: 'Aug' },
                { value: '09', label: 'Sep' },
                { value: '10', label: 'Oct' },
                { value: '11', label: 'Nov' },
                { value: '12', label: 'Dec' }
            ];
            
            let html = '<div class="mb-3"><div class="d-flex flex-wrap gap-2 align-items-start">';
            
            years.forEach(year => {
                const isYearSelected = window.pricingRatesState.selectedYears.has(year);
                html += `
                    <div class="year-selector-group">
                        <button type="button" 
                                class="btn ${isYearSelected ? 'btn-primary' : 'btn-outline-primary'} year-btn" 
                                onclick="toggleYear(${year})"
                                data-year="${year}">
                            ${year}
                            <i class="bi bi-chevron-${isYearSelected ? 'down' : 'right'} ms-1"></i>
                        </button>
                        <div class="month-container mt-2" id="months-${year}" style="display: ${isYearSelected ? 'flex' : 'none'}; flex-wrap: wrap; gap: 4px;">
                            ${months.map(month => {
                                const monthKey = `${year}-${month.value}`;
                                const isSelected = window.pricingRatesState.selectedMonths.has(monthKey);
                                return `
                                    <button type="button" 
                                            class="btn btn-sm ${isSelected ? 'btn-success' : 'btn-outline-secondary'} month-btn" 
                                            onclick="toggleMonth('${monthKey}')"
                                            data-month="${monthKey}">
                                        ${month.label}
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            });
            
            html += '</div></div>';
            return html;
        }
        
        function generateAllDaysForSelectedMonths(existingDataMap) {
            const allDays = [];
            const state = window.pricingRatesState;
            
            state.selectedMonths.forEach(monthKey => {
                const [year, month] = monthKey.split('-');
                const yearNum = parseInt(year);
                const monthNum = parseInt(month);
                
                // Get number of days in month
                const daysInMonth = new Date(yearNum, monthNum, 0).getDate();
                
                // Get base rates for this year
                const baseRate = state.baseRatesByYear[yearNum] || (yearNum < 2025 ? 275 : 550);
                const hourlyRate = state.hourlyRatesByYear[yearNum] || (yearNum < 2025 ? 45 : 70);
                
                // Generate all days for this month
                for (let day = 1; day <= daysInMonth; day++) {
                    const dateStr = `${year}-${month}-${String(day).padStart(2, '0')}`;
                    const date = new Date(yearNum, monthNum - 1, day);
                    
                    // Skip past dates
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    if (date < today) continue;
                    
                    // Check if we have existing data for this date
                    const existing = existingDataMap.get(dateStr);
                    
                    // Calculate day of week
                    const dayOfWeek = date.toLocaleDateString('en-US', { weekday: 'short' });
                    
                    // Calculate total cost (4 hours, 2 helpers)
                    let totalCost = 0;
                    let isSpecialDate = false;
                    let specialLabel = '';
                    let rateType = '';
                    let specialMultiplier = null;
                    
                    if (existing) {
                        // Use existing data
                        totalCost = existing.totalCost;
                        isSpecialDate = existing.isSpecialDate;
                        specialLabel = existing.specialLabel;
                        rateType = existing.rateType;
                        specialMultiplier = existing.specialMultiplier;
                    } else {
                        // Calculate: base rate * 2 helpers = base cost
                        // For 4 hours, no extra hours needed (first 4 hours are included)
                        totalCost = baseRate * 2;
                        
                        // Check if it's a special date (we'd need to call API or use special dates data)
                        // For now, we'll mark it based on existing data patterns
                    }
                    
                    allDays.push({
                        date: dateStr,
                        dayOfWeek: dayOfWeek,
                        baseRate: existing?.baseRate || baseRate,
                        hourlyRate: existing?.hourlyRate || hourlyRate,
                        totalCost: totalCost,
                        isSpecialDate: isSpecialDate,
                        specialLabel: specialLabel,
                        rateType: rateType,
                        specialMultiplier: specialMultiplier
                    });
                }
            });
            
            // Sort by date
            allDays.sort((a, b) => a.date.localeCompare(b.date));
            
            return allDays;
        }
        
        function toggleYear(year) {
            const state = window.pricingRatesState;
            const isSelected = state.selectedYears.has(year);
            
            if (isSelected) {
                state.selectedYears.delete(year);
                // Remove all months for this year
                const monthsToRemove = [];
                state.selectedMonths.forEach(monthKey => {
                    if (monthKey.startsWith(`${year}-`)) {
                        monthsToRemove.push(monthKey);
                    }
                });
                monthsToRemove.forEach(monthKey => state.selectedMonths.delete(monthKey));
            } else {
                state.selectedYears.add(year);
            }
            
            // Refresh display
            refreshPricingRatesTable();
        }
        
        function toggleMonth(monthKey) {
            const state = window.pricingRatesState;
            const isSelected = state.selectedMonths.has(monthKey);
            
            if (isSelected) {
                state.selectedMonths.delete(monthKey);
            } else {
                state.selectedMonths.add(monthKey);
                // Ensure year is also selected
                const year = parseInt(monthKey.split('-')[0]);
                state.selectedYears.add(year);
            }
            
            // Refresh display
            refreshPricingRatesTable();
        }
        
        function refreshPricingRatesTable() {
            // Update UI
            const state = window.pricingRatesState;
            
            // Update year buttons
            document.querySelectorAll('.year-btn').forEach(btn => {
                const year = parseInt(btn.getAttribute('data-year'));
                const isSelected = state.selectedYears.has(year);
                btn.className = `btn ${isSelected ? 'btn-primary' : 'btn-outline-primary'} year-btn`;
                const icon = btn.querySelector('i');
                if (icon) {
                    icon.className = `bi bi-chevron-${isSelected ? 'down' : 'right'} ms-1`;
                }
                
                // Show/hide months
                const monthContainer = document.getElementById(`months-${year}`);
                if (monthContainer) {
                    monthContainer.style.display = isSelected ? 'flex' : 'none';
                }
            });
            
            // Update month buttons
            document.querySelectorAll('.month-btn').forEach(btn => {
                const monthKey = btn.getAttribute('data-month');
                const isSelected = state.selectedMonths.has(monthKey);
                btn.className = `btn btn-sm ${isSelected ? 'btn-success' : 'btn-outline-secondary'} month-btn`;
            });
            
            // Regenerate table data
            const allDays = generateAllDaysForSelectedMonths(state.allDaysData);
            
            // Ensure at least 31 records
            if (allDays.length < 31 && state.selectedMonths.size > 0) {
                // Auto-expand to get more days
                const now = new Date();
                const currentYear = now.getFullYear();
                const currentMonth = now.getMonth() + 1;
                
                for (let i = 0; i < 12 && allDays.length < 31; i++) {
                    const month = ((currentMonth - 1 + i) % 12) + 1;
                    const year = currentYear + Math.floor((currentMonth - 1 + i) / 12);
                    const monthKey = `${year}-${String(month).padStart(2, '0')}`;
                    if (!state.selectedMonths.has(monthKey)) {
                        state.selectedMonths.add(monthKey);
                        state.selectedYears.add(year);
                    }
                }
                // Regenerate
                const expandedDays = generateAllDaysForSelectedMonths(state.allDaysData);
                allDays.length = 0;
                allDays.push(...expandedDays);
            }
            
            // Update table
            if (window.pricingTable) {
                const tbody = window.pricingTable.table().body();
                tbody.empty();
                
                allDays.forEach(row => {
                    const tr = $('<tr>').addClass(row.isSpecialDate ? 'table-info' : '');
                    tr.append($('<td>').text(row.date));
                    tr.append($('<td>').html(`<strong>${row.dayOfWeek}</strong>`));
                    tr.append($('<td>').text(`$${row.baseRate.toFixed(2)}`));
                    tr.append($('<td>').text(`$${row.hourlyRate.toFixed(2)}`));
                    tr.append($('<td>').text(`$${row.totalCost.toFixed(2)}`));
                    tr.append($('<td>').html(row.isSpecialDate ? `<span class="badge bg-warning">${row.specialLabel || row.rateType || 'Special'}</span>` : '<span class="text-muted">-</span>'));
                    tr.append($('<td>').html(row.specialMultiplier ? `${row.specialMultiplier}x` : '<span class="text-muted">-</span>'));
                    tbody.append(tr);
                });
                
                window.pricingTable.draw();
            }
        }
            
            const tableHTML = `
                ${filterButtons}
                <div class="table-responsive">
                    <table id="pricingRatesTable" class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Time Category</th>
                                <th>Base Rate</th>
                                <th>Hourly Rate</th>
                                <th>Total Cost (4h, 2 helpers)</th>
                                <th>Special Date</th>
                                <th>Multiplier</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableData.map(row => `
                                <tr class="${row.isSpecialDate ? 'table-info' : ''} ${row.status === 'pass' ? '' : 'table-danger'}" data-time-category="${row.timeCategory}" data-date="${row.date}">
                                    <td>${row.date}</td>
                                    <td>${row.timeCategory}</td>
                                    <td>$${row.baseRate.toFixed(2)}</td>
                                    <td>$${row.hourlyRate.toFixed(2)}</td>
                                    <td>$${row.totalCost.toFixed(2)}</td>
                                    <td>${row.isSpecialDate ? `<span class="badge bg-warning">${row.specialLabel || row.rateType || 'Special'}</span>` : '<span class="text-muted">-</span>'}</td>
                                    <td>${row.specialMultiplier ? `${row.specialMultiplier}x` : '<span class="text-muted">-</span>'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            resultsDiv.innerHTML = tableHTML;
            
            // Initialize DataTable
            setTimeout(() => {
                if ($.fn.DataTable.isDataTable('#pricingRatesTable')) {
                    $('#pricingRatesTable').DataTable().destroy();
                }
                window.pricingTable = $('#pricingRatesTable').DataTable({
                    pageLength: 50,
                    order: [[0, 'asc']],
                    dom: 'Bfrtip',
                    buttons: ['copy', 'csv', 'excel'],
                    language: {
                        search: "Search all columns:"
                    }
                });
            }, 100);
        }
        
        function filterPricingTable(category) {
            if (window.pricingTable) {
                // Clear year/month filters when using category buttons
                document.getElementById('pricingYearFilter').value = '';
                document.getElementById('pricingMonthFilter').value = '';
                document.getElementById('pricingDateSearch').value = '';
                
                if (category === 'all') {
                    window.pricingTable.column(1).search('').draw();
                } else {
                    window.pricingTable.column(1).search('^' + category + '$', true, false).draw();
                }
            }
        }
        
        function filterPricingByYearMonth() {
            if (!window.pricingTable) return;
            
            const year = document.getElementById('pricingYearFilter').value;
            const month = document.getElementById('pricingMonthFilter').value;
            
            // Clear category and date filters when using year/month
            document.getElementById('pricingDateSearch').value = '';
            
            // Clear category filter buttons
            const categoryButtons = document.querySelectorAll('[onclick^="filterPricingTable"]');
            categoryButtons.forEach(btn => {
                if (btn.textContent.trim() === 'All') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            if (!year && !month) {
                // No filters - show all
                window.pricingTable.column(0).search('').draw();
                window.pricingTable.column(1).search('').draw();
                return;
            }
            
            // Build regex pattern for date filtering
            let datePattern = '';
            if (year && month) {
                // Filter for specific year and month: YYYY-MM-XX (e.g., 2026-01-XX)
                // This ensures when you select year 2026 and month January, it only shows January 2026
                datePattern = `^${year}-${month}-\\d{2}$`;
            } else if (year) {
                // Filter for entire year: YYYY-XX-XX
                datePattern = `^${year}-\\d{2}-\\d{2}$`;
            } else if (month) {
                // Filter for month across all years: XXXX-MM-XX
                datePattern = `^\\d{4}-${month}-\\d{2}$`;
            }
            
            if (datePattern) {
                window.pricingTable.column(0).search(datePattern, true, false).draw();
            }
        }
        
        function clearYearMonthFilter() {
            document.getElementById('pricingYearFilter').value = '';
            document.getElementById('pricingMonthFilter').value = '';
            filterPricingByYearMonth();
        }
        
        function clearDateSearch() {
            document.getElementById('pricingDateSearch').value = '';
            searchPricingByDate('');
        }
        
        function searchPricingByDate(dateStr) {
            if (!window.pricingTable) return;
            
            // Clear year/month filters when using date search
            document.getElementById('pricingYearFilter').value = '';
            document.getElementById('pricingMonthFilter').value = '';
            
            // Clear category filter buttons
            const categoryButtons = document.querySelectorAll('[onclick^="filterPricingTable"]');
            categoryButtons.forEach(btn => {
                if (btn.textContent.trim() === 'All') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            if (dateStr) {
                // Convert date input (YYYY-MM-DD) to match table format
                // The table date column should be in YYYY-MM-DD format
                window.pricingTable.column(0).search('^' + dateStr + '$', true, false).draw();
            } else {
                window.pricingTable.column(0).search('').draw();
            }
        }
        
        function displayAdvancedView(data, testName, resultsDiv) {
            // Original advanced view
            let resultsHTML = '';
            
            if (data.results && data.results.length > 0) {
                data.results.forEach(result => {
                    const resultClass = result.status === 'error' || result.status === 'fail' ? 'error' : 
                                      result.status === 'warning' ? 'warning' : '';
                    const icon = result.status === 'error' || result.status === 'fail' ? 'bi-x-circle' :
                               result.status === 'warning' ? 'bi-exclamation-triangle' : 'bi-check-circle';
                    const iconColor = result.status === 'error' || result.status === 'fail' ? 'text-danger' :
                                    result.status === 'warning' ? 'text-warning' : 'text-success';
                    
                    resultsHTML += `
                        <div class="test-result ${resultClass}">
                            <h5><i class="bi ${icon} ${iconColor} me-2"></i>${result.name || 'Test Case'}</h5>
                            <p class="mb-2"><strong>Status:</strong> <span class="badge bg-${result.status === 'pass' ? 'success' : result.status === 'error' || result.status === 'fail' ? 'danger' : 'warning'}">${result.status}</span></p>
                            ${result.message ? `<p class="mb-2">${result.message}</p>` : ''}
                            ${result.expected ? `<p class="mb-1"><strong>Expected:</strong> ${result.expected}</p>` : ''}
                            ${result.actual ? `<p class="mb-2"><strong>Actual:</strong> ${result.actual}</p>` : ''}
                            ${result.data && result.data.configInfo ? `
                                <div class="alert alert-info mt-2 mb-2">
                                    <i class="bi bi-info-circle me-2"></i><strong>Configuration:</strong>
                                    <div class="mt-1">${result.data.configInfo}</div>
                                </div>
                            ` : ''}
                            ${result.data ? `<pre>${JSON.stringify(result.data, null, 2)}</pre>` : ''}
                        </div>
                    `;
                });
            } else if (data.error) {
                resultsHTML = `
                    <div class="test-result error">
                        <h5><i class="bi bi-x-circle me-2"></i>Error</h5>
                        <p>${data.error}</p>
                    </div>
                `;
            }
            
            resultsDiv.innerHTML = resultsHTML;
        }
    </script>
</body>
</html>
